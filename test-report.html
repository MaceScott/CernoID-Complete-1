<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title id="head-title">test-report.html</title>
      <link href="assets\style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <h1 id="title">test-report.html</h1>
    <p>Report generated on 26-Mar-2025 at 22:31:55 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a>
        v4.1.1</p>
    <div id="environment-header">
      <h2>Environment</h2>
    </div>
    <table id="environment"></table>
    <!-- TEMPLATES -->
      <template id="template_environment_row">
      <tr>
        <td></td>
        <td></td>
      </tr>
    </template>
    <template id="template_results-table__body--empty">
      <tbody class="results-table-row">
        <tr id="not-found-message">
          <td colspan="4">No results found. Check the filters.</th>
        </tr>
    </template>
    <template id="template_results-table__tbody">
      <tbody class="results-table-row">
        <tr class="collapsible">
        </tr>
        <tr class="extras-row">
          <td class="extra" colspan="4">
            <div class="extraHTML"></div>
            <div class="media">
              <div class="media-container">
                  <div class="media-container__nav--left"><</div>
                  <div class="media-container__viewport">
                    <img src="" />
                    <video controls>
                      <source src="" type="video/mp4">
                    </video>
                  </div>
                  <div class="media-container__nav--right">></div>
                </div>
                <div class="media__name"></div>
                <div class="media__counter"></div>
            </div>
            <div class="logwrapper">
              <div class="logexpander"></div>
              <div class="log"></div>
            </div>
          </td>
        </tr>
      </tbody>
    </template>
    <!-- END TEMPLATES -->
    <div class="summary">
      <div class="summary__data">
        <h2>Summary</h2>
        <div class="additional-summary prefix">
        </div>
        <p class="run-count">5 tests took 285 ms.</p>
        <p class="filter">(Un)check the boxes to filter the results.</p>
        <div class="summary__reload">
          <div class="summary__reload__button hidden" onclick="location.reload()">
            <div>There are still tests running. <br />Reload this page to get the latest results!</div>
          </div>
        </div>
        <div class="summary__spacer"></div>
        <div class="controls">
          <div class="filters">
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="failed" />
            <span class="failed">4 Failed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="passed" />
            <span class="passed">1 Passed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="skipped" disabled/>
            <span class="skipped">0 Skipped,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xfailed" disabled/>
            <span class="xfailed">0 Expected failures,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xpassed" disabled/>
            <span class="xpassed">0 Unexpected passes,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="error" />
            <span class="error">66 Errors,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="rerun" disabled/>
            <span class="rerun">0 Reruns</span>
          </div>
          <div class="collapse">
            <button id="show_all_details">Show all details</button>&nbsp;/&nbsp;<button id="hide_all_details">Hide all details</button>
          </div>
        </div>
      </div>
      <div class="additional-summary summary">
      </div>
      <div class="additional-summary postfix">
      </div>
    </div>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable" data-column-type="result">Result</th>
          <th class="sortable" data-column-type="testId">Test</th>
          <th class="sortable" data-column-type="duration">Duration</th>
          <th>Links</th>
        </tr>
      </thead>
    </table>
  </body>
  <footer>
    <div id="data-container" data-jsonblob="{&#34;environment&#34;: {&#34;Python&#34;: &#34;3.10.9&#34;, &#34;Platform&#34;: &#34;Windows-10-10.0.22631-SP0&#34;, &#34;Packages&#34;: {&#34;pytest&#34;: &#34;7.4.3&#34;, &#34;pluggy&#34;: &#34;1.5.0&#34;}, &#34;Plugins&#34;: {&#34;anyio&#34;: &#34;4.9.0&#34;, &#34;asyncio&#34;: &#34;0.21.1&#34;, &#34;clarity&#34;: &#34;1.0.1&#34;, &#34;cov&#34;: &#34;4.1.0&#34;, &#34;env&#34;: &#34;1.1.1&#34;, &#34;html&#34;: &#34;4.1.1&#34;, &#34;metadata&#34;: &#34;3.1.1&#34;, &#34;mock&#34;: &#34;3.12.0&#34;, &#34;randomly&#34;: &#34;3.15.0&#34;, &#34;sugar&#34;: &#34;0.9.7&#34;, &#34;timeout&#34;: &#34;2.2.0&#34;, &#34;xdist&#34;: &#34;3.3.1&#34;}}, &#34;tests&#34;: {&#34;backend/tests/test_system.py::test_admin_stats&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_admin_stats::setup&#34;, &#34;duration&#34;: &#34;171 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_admin_stats::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;171 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n\n---------------------------- Captured stderr setup -----------------------------\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;core.config.manager&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Loaded configuration from &amp;lt;MagicMock name=&amp;#x27;mock.Path()&amp;#x27; id=&amp;#x27;2411308468304&amp;#x27;&amp;gt;&amp;quot;}\n2025-03-26 22:31:27,590 - SystemBootstrap - INFO - Starting system initialization...\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;SystemBootstrap&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Starting system initialization...&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;core.database.session&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Creating database tables...&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;core.database.session&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Initializing database session...&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;core.database.session&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Database session initialized successfully&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;core.database.session&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Failed to create database tables: `sslnegotiation` parameter must be one of: postgres, direct&amp;quot;}\n2025-03-26 22:31:27,596 - SystemBootstrap - ERROR - Database initialization failed: `sslnegotiation` parameter must be one of: postgres, direct\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;SystemBootstrap&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Database initialization failed: `sslnegotiation` parameter must be one of: postgres, direct&amp;quot;}\n2025-03-26 22:31:27,597 - SystemBootstrap - ERROR - System initialization failed: `sslnegotiation` parameter must be one of: postgres, direct\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;SystemBootstrap&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;System initialization failed: `sslnegotiation` parameter must be one of: postgres, direct&amp;quot;}\n2025-03-26 22:31:27,597 - SystemBootstrap - INFO - Starting system cleanup...\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;SystemBootstrap&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Starting system cleanup...&amp;quot;}\n2025-03-26 22:31:27,598 - SystemBootstrap - INFO - System cleanup completed\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;SystemBootstrap&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;System cleanup completed&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;src.main&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Failed to initialize application: `sslnegotiation` parameter must be one of: postgres, direct&amp;quot;}\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;src.main&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;Starting application cleanup...&amp;quot;}\n\n------------------------------ Captured log setup ------------------------------\nINFO     core.config.manager:manager.py:32 Loaded configuration from &amp;lt;MagicMock name=&amp;#x27;mock.Path()&amp;#x27; id=&amp;#x27;2411308468304&amp;#x27;&amp;gt;\nINFO     SystemBootstrap:bootstrap.py:27 Starting system initialization...\nINFO     core.database.session:session.py:99 Creating database tables...\nINFO     core.database.session:session.py:28 Initializing database session...\nINFO     core.database.session:session.py:51 Database session initialized successfully\nERROR    core.database.session:session.py:113 Failed to create database tables: `sslnegotiation` parameter must be one of: postgres, direct\nERROR    SystemBootstrap:bootstrap.py:67 Database initialization failed: `sslnegotiation` parameter must be one of: postgres, direct\nERROR    SystemBootstrap:bootstrap.py:48 System initialization failed: `sslnegotiation` parameter must be one of: postgres, direct\nINFO     SystemBootstrap:bootstrap.py:149 Starting system cleanup...\nINFO     SystemBootstrap:bootstrap.py:165 System cleanup completed\nERROR    src.main:main.py:64 Failed to initialize application: `sslnegotiation` parameter must be one of: postgres, direct\nINFO     src.main:main.py:68 Starting application cleanup...\n&#34;}], &#34;backend/tests/test_system.py::test_backup_config&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_backup_config::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_backup_config::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_storage_metrics&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_storage_metrics::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_storage_metrics::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_system_metrics&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_system_metrics::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_system_metrics::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_admin_access_logs&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_admin_access_logs::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_admin_access_logs::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_admin_users&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_admin_users::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_admin_users::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_system_health&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_system_health::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_system_health::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_create_backup&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_create_backup::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_create_backup::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_system.py::test_system_metrics_unauthorized&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_system.py::test_system_metrics_unauthorized::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_system.py::test_system_metrics_unauthorized::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_security.py::test_superuser_management&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_security.py::test_superuser_management::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_security.py::test_superuser_management::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py, line 78\n  def test_superuser_management(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py:78\n&#34;}], &#34;backend/tests/test_security.py::test_user_active_status&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_security.py::test_user_active_status::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_security.py::test_user_active_status::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py, line 51\n  def test_user_active_status(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py:51\n&#34;}], &#34;backend/tests/test_security.py::test_user_password_management&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_security.py::test_user_password_management::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_security.py::test_user_password_management::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py, line 20\n  def test_user_password_management(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_security.py:20\n&#34;}], &#34;backend/tests/test_security.py::test_password_hashing&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;backend/tests/test_security.py::test_password_hashing&#34;, &#34;duration&#34;: &#34;11 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_security.py::test_password_hashing&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;11 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;def test_password_hashing():\n        &amp;quot;&amp;quot;&amp;quot;Test password hashing and verification.&amp;quot;&amp;quot;&amp;quot;\n        password = &amp;quot;testpassword123&amp;quot;\n        hashed = hash_password(password)\n    \n        # Test that hashing produces different results\n        assert hashed != password\n&amp;gt;       assert hash_password(password) != hashed  # Should generate different salt\nE       assert != failed. [pytest-clarity diff shown]\nE         \nE         LHS vs RHS shown below\nE         \nE         hashed_password\nE         \n\nbackend\\tests\\test_security.py:14: AssertionError\n&#34;}], &#34;backend/tests/test_core/test_basic.py::test_basic&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_basic.py::test_basic&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_basic.py::test_basic&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;backend/tests/test_models.py::test_create_access_log&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_models.py::test_create_access_log::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_models.py::test_create_access_log::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py, line 52\n  def test_create_access_log(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py:52\n&#34;}], &#34;backend/tests/test_models.py::test_create_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_models.py::test_create_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_models.py::test_create_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py, line 6\n  def test_create_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py:6\n&#34;}], &#34;backend/tests/test_models.py::test_unique_constraints&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_models.py::test_unique_constraints::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_models.py::test_unique_constraints::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py, line 116\n  def test_unique_constraints(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py:116\n&#34;}], &#34;backend/tests/test_models.py::test_cascade_delete_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_models.py::test_cascade_delete_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_models.py::test_cascade_delete_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py, line 81\n  def test_cascade_delete_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py:81\n&#34;}], &#34;backend/tests/test_models.py::test_create_face_encoding&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_models.py::test_create_face_encoding::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_models.py::test_create_face_encoding::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py, line 26\n  def test_create_face_encoding(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_models.py:26\n&#34;}], &#34;backend/tests/test_minimal.py::test_minimal&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_minimal.py::test_minimal::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_minimal.py::test_minimal::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_minimal.py, line 4\n  def test_minimal(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_minimal.py:4\n&#34;}], &#34;backend/tests/test_persons.py::test_update_person_unauthorized&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_update_person_unauthorized::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_update_person_unauthorized::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_get_nonexistent_person&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_get_nonexistent_person::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_get_nonexistent_person::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_delete_person&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_delete_person::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_delete_person::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_create_person_unauthorized&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_create_person_unauthorized::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_create_person_unauthorized::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_create_person&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_create_person::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_create_person::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_get_person&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_get_person::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_get_person::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_delete_person_unauthorized&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_delete_person_unauthorized::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_delete_person_unauthorized::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_list_persons&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_list_persons::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_list_persons::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_update_person&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_update_person::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_update_person::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_persons.py::test_list_persons_with_filters&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_persons.py::test_list_persons_with_filters::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_persons.py::test_list_persons_with_filters::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_face_recognition_endpoint&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_face_recognition_endpoint::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_face_recognition_endpoint::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_access_log_creation&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_access_log_creation::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_access_log_creation::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_register_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_register_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_register_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_update_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_update_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_update_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_invalid_token&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_invalid_token::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_invalid_token::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_get_current_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_get_current_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_get_current_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_health_check&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_health_check::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_health_check::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_unauthorized_access&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_unauthorized_access::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_unauthorized_access::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_api/test_endpoints.py::test_login_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api/test_endpoints.py::test_login_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api/test_endpoints.py::test_login_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;@pytest.fixture\n    def client():\n        &amp;quot;&amp;quot;&amp;quot;Create a test client.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       return TestClient(app)\nE       NameError: name &amp;#x27;app&amp;#x27; is not defined\n\nbackend\\tests\\test_api\\test_endpoints.py:10: NameError\n&#34;}], &#34;backend/tests/test_simple.py::test_simple&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_simple.py::test_simple::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_simple.py::test_simple::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_simple.py, line 4\n  def test_simple(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_simple.py:4\n&#34;}], &#34;backend/tests/test_auth.py::test_login_with_credentials&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_login_with_credentials::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_login_with_credentials::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_register_duplicate_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_register_duplicate_user::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_register_duplicate_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_health_check&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_health_check::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_health_check::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_get_current_user_invalid_token&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_get_current_user_invalid_token::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_get_current_user_invalid_token::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_login_with_invalid_credentials&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_login_with_invalid_credentials::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_login_with_invalid_credentials::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_get_current_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_get_current_user::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_get_current_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_register_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_register_user::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_register_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_auth.py::test_face_login&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_auth.py::test_face_login::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_auth.py::test_face_login::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_recognize_faces_unauthorized&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_recognize_faces_unauthorized::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_recognize_faces_unauthorized::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_search_faces&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_search_faces::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_search_faces::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_recognize_file&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_recognize_file::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_recognize_file::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_recognize_faces&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_recognize_faces::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_recognize_faces::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_face_detection&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_face_detection::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_face_detection::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_recognize_with_high_confidence&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_recognize_with_high_confidence::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_recognize_with_high_confidence::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_recognition.py::test_recognize_invalid_image&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_recognition.py::test_recognize_invalid_image::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_recognition.py::test_recognize_invalid_image::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;app = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n&amp;gt;           await system.initialize()\n\nbackend\\src\\main.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbackend\\src\\core\\system\\bootstrap.py:33: in initialize\n    await self._init_database(config)\nbackend\\src\\core\\system\\bootstrap.py:56: in _init_database\n    await db_session.create_all()\nbackend\\src\\core\\database\\session.py:107: in create_all\n    async with self._engine.begin() as conn:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:1064: in begin\n    async with conn:\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\base.py:121: in __aenter__\n    return await self.start(is_ctxmanager=True)\n.venv\\lib\\site-packages\\sqlalchemy\\ext\\asyncio\\engine.py:274: in start\n    await greenlet_spawn(self.sync_engine.connect)\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:201: in greenlet_spawn\n    result = context.throw(*sys.exc_info())\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3274: in connect\n    return self._connection_cls(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:146: in __init__\n    self._dbapi_connection = engine.raw_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\base.py:3298: in raw_connection\n    return self.pool.connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:449: in connect\n    return _ConnectionFairy._checkout(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:1264: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:713: in checkout\n    rec = pool._do_get()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:179: in _do_get\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:177: in _do_get\n    return self._create_connection()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:390: in _create_connection\n    return _ConnectionRecord(self)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:675: in __init__\n    self.__connect()\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:901: in __connect\n    with util.safe_reraise():\n.venv\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n.venv\\lib\\site-packages\\sqlalchemy\\pool\\base.py:897: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\create.py:646: in connect\n    return dialect.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\engine\\default.py:622: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n.venv\\lib\\site-packages\\sqlalchemy\\dialects\\postgresql\\asyncpg.py:961: in connect\n    await_only(creator_fn(*arg, **kw)),\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:132: in await_only\n    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501\n.venv\\lib\\site-packages\\sqlalchemy\\util\\_concurrency_py3k.py:196: in greenlet_spawn\n    value = await result\n.venv\\lib\\site-packages\\asyncpg\\connection.py:2421: in connect\n    return await connect_utils._connect(\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:1041: in _connect\n    addrs, params, config = _parse_connect_arguments(**kwargs)\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:749: in _parse_connect_arguments\n    addrs, params = _parse_connect_dsn_and_args(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _parse_connect_dsn_and_args(*, dsn, host, port, user,\n                                    password, passfile, database, ssl,\n                                    direct_tls, server_settings,\n                                    target_session_attrs, krbsrvname, gsslib):\n        # `auth_hosts` is the version of host information for the purposes\n        # of reading the pgpass file.\n        auth_hosts = None\n        sslcert = sslkey = sslrootcert = sslcrl = sslpassword = None\n        ssl_min_protocol_version = ssl_max_protocol_version = None\n        sslnegotiation = None\n    \n        if dsn:\n            parsed = urllib.parse.urlparse(dsn)\n    \n            if parsed.scheme not in {&amp;#x27;postgresql&amp;#x27;, &amp;#x27;postgres&amp;#x27;}:\n                raise exceptions.ClientConfigurationError(\n                    &amp;#x27;invalid DSN: scheme is expected to be either &amp;#x27;\n                    &amp;#x27;&amp;quot;postgresql&amp;quot; or &amp;quot;postgres&amp;quot;, got {!r}&amp;#x27;.format(parsed.scheme))\n    \n            if parsed.netloc:\n                if &amp;#x27;@&amp;#x27; in parsed.netloc:\n                    dsn_auth, _, dsn_hostspec = parsed.netloc.partition(&amp;#x27;@&amp;#x27;)\n                else:\n                    dsn_hostspec = parsed.netloc\n                    dsn_auth = &amp;#x27;&amp;#x27;\n            else:\n                dsn_auth = dsn_hostspec = &amp;#x27;&amp;#x27;\n    \n            if dsn_auth:\n                dsn_user, _, dsn_password = dsn_auth.partition(&amp;#x27;:&amp;#x27;)\n            else:\n                dsn_user = dsn_password = &amp;#x27;&amp;#x27;\n    \n            if not host and dsn_hostspec:\n                host, port = _parse_hostlist(dsn_hostspec, port, unquote=True)\n    \n            if parsed.path and database is None:\n                dsn_database = parsed.path\n                if dsn_database.startswith(&amp;#x27;/&amp;#x27;):\n                    dsn_database = dsn_database[1:]\n                database = urllib.parse.unquote(dsn_database)\n    \n            if user is None and dsn_user:\n                user = urllib.parse.unquote(dsn_user)\n    \n            if password is None and dsn_password:\n                password = urllib.parse.unquote(dsn_password)\n    \n            if parsed.query:\n                query = urllib.parse.parse_qs(parsed.query, strict_parsing=True)\n                for key, val in query.items():\n                    if isinstance(val, list):\n                        query[key] = val[-1]\n    \n                if &amp;#x27;port&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;port&amp;#x27;)\n                    if not port and val:\n                        port = [int(p) for p in val.split(&amp;#x27;,&amp;#x27;)]\n    \n                if &amp;#x27;host&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;host&amp;#x27;)\n                    if not host and val:\n                        host, port = _parse_hostlist(val, port)\n    \n                if &amp;#x27;dbname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;dbname&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;database&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;database&amp;#x27;)\n                    if database is None:\n                        database = val\n    \n                if &amp;#x27;user&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;user&amp;#x27;)\n                    if user is None:\n                        user = val\n    \n                if &amp;#x27;password&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;password&amp;#x27;)\n                    if password is None:\n                        password = val\n    \n                if &amp;#x27;passfile&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;passfile&amp;#x27;)\n                    if passfile is None:\n                        passfile = val\n    \n                if &amp;#x27;sslmode&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;sslmode&amp;#x27;)\n                    if ssl is None:\n                        ssl = val\n    \n                if &amp;#x27;sslcert&amp;#x27; in query:\n                    sslcert = query.pop(&amp;#x27;sslcert&amp;#x27;)\n    \n                if &amp;#x27;sslkey&amp;#x27; in query:\n                    sslkey = query.pop(&amp;#x27;sslkey&amp;#x27;)\n    \n                if &amp;#x27;sslrootcert&amp;#x27; in query:\n                    sslrootcert = query.pop(&amp;#x27;sslrootcert&amp;#x27;)\n    \n                if &amp;#x27;sslnegotiation&amp;#x27; in query:\n                    sslnegotiation = query.pop(&amp;#x27;sslnegotiation&amp;#x27;)\n    \n                if &amp;#x27;sslcrl&amp;#x27; in query:\n                    sslcrl = query.pop(&amp;#x27;sslcrl&amp;#x27;)\n    \n                if &amp;#x27;sslpassword&amp;#x27; in query:\n                    sslpassword = query.pop(&amp;#x27;sslpassword&amp;#x27;)\n    \n                if &amp;#x27;ssl_min_protocol_version&amp;#x27; in query:\n                    ssl_min_protocol_version = query.pop(\n                        &amp;#x27;ssl_min_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;ssl_max_protocol_version&amp;#x27; in query:\n                    ssl_max_protocol_version = query.pop(\n                        &amp;#x27;ssl_max_protocol_version&amp;#x27;\n                    )\n    \n                if &amp;#x27;target_session_attrs&amp;#x27; in query:\n                    dsn_target_session_attrs = query.pop(\n                        &amp;#x27;target_session_attrs&amp;#x27;\n                    )\n                    if target_session_attrs is None:\n                        target_session_attrs = dsn_target_session_attrs\n    \n                if &amp;#x27;krbsrvname&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;krbsrvname&amp;#x27;)\n                    if krbsrvname is None:\n                        krbsrvname = val\n    \n                if &amp;#x27;gsslib&amp;#x27; in query:\n                    val = query.pop(&amp;#x27;gsslib&amp;#x27;)\n                    if gsslib is None:\n                        gsslib = val\n    \n                if query:\n                    if server_settings is None:\n                        server_settings = query\n                    else:\n                        server_settings = {**query, **server_settings}\n    \n        if not host:\n            hostspec = os.environ.get(&amp;#x27;PGHOST&amp;#x27;)\n            if hostspec:\n                host, port = _parse_hostlist(hostspec, port)\n    \n        if not host:\n            auth_hosts = [&amp;#x27;localhost&amp;#x27;]\n    \n            if _system == &amp;#x27;Windows&amp;#x27;:\n                host = [&amp;#x27;localhost&amp;#x27;]\n            else:\n                host = [&amp;#x27;/run/postgresql&amp;#x27;, &amp;#x27;/var/run/postgresql&amp;#x27;,\n                        &amp;#x27;/tmp&amp;#x27;, &amp;#x27;/private/tmp&amp;#x27;, &amp;#x27;localhost&amp;#x27;]\n    \n        if not isinstance(host, (list, tuple)):\n            host = [host]\n    \n        if auth_hosts is None:\n            auth_hosts = host\n    \n        if not port:\n            portspec = os.environ.get(&amp;#x27;PGPORT&amp;#x27;)\n            if portspec:\n                if &amp;#x27;,&amp;#x27; in portspec:\n                    port = [int(p) for p in portspec.split(&amp;#x27;,&amp;#x27;)]\n                else:\n                    port = int(portspec)\n            else:\n                port = 5432\n    \n        elif isinstance(port, (list, tuple)):\n            port = [int(p) for p in port]\n    \n        else:\n            port = int(port)\n    \n        port = _validate_port_spec(host, port)\n    \n        if user is None:\n            user = os.getenv(&amp;#x27;PGUSER&amp;#x27;)\n            if not user:\n                user = getpass.getuser()\n    \n        if password is None:\n            password = os.getenv(&amp;#x27;PGPASSWORD&amp;#x27;)\n    \n        if database is None:\n            database = os.getenv(&amp;#x27;PGDATABASE&amp;#x27;)\n    \n        if database is None:\n            database = user\n    \n        if user is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine user name to connect with&amp;#x27;)\n    \n        if database is None:\n            raise exceptions.ClientConfigurationError(\n                &amp;#x27;could not determine database name to connect to&amp;#x27;)\n    \n        if password is None:\n            if passfile is None:\n                passfile = os.getenv(&amp;#x27;PGPASSFILE&amp;#x27;)\n    \n            if passfile is None:\n                homedir = compat.get_pg_home_directory()\n                if homedir:\n                    passfile = homedir / PGPASSFILE\n                else:\n                    passfile = None\n            else:\n                passfile = pathlib.Path(passfile)\n    \n            if passfile is not None:\n                password = _read_password_from_pgpass(\n                    hosts=auth_hosts, ports=port,\n                    database=database, user=user,\n                    passfile=passfile)\n    \n        addrs = []\n        have_tcp_addrs = False\n        for h, p in zip(host, port):\n            if h.startswith(&amp;#x27;/&amp;#x27;):\n                # UNIX socket name\n                if &amp;#x27;.s.PGSQL.&amp;#x27; not in h:\n                    h = os.path.join(h, &amp;#x27;.s.PGSQL.{}&amp;#x27;.format(p))\n                addrs.append(h)\n            else:\n                # TCP host/port\n                addrs.append((h, p))\n                have_tcp_addrs = True\n    \n        if not addrs:\n            raise exceptions.InternalClientError(\n                &amp;#x27;could not determine the database address to connect to&amp;#x27;)\n    \n        if ssl is None:\n            ssl = os.getenv(&amp;#x27;PGSSLMODE&amp;#x27;)\n    \n        if ssl is None and have_tcp_addrs:\n            ssl = &amp;#x27;prefer&amp;#x27;\n    \n        if direct_tls is not None:\n            sslneg = (\n                SSLNegotiation.direct if direct_tls else SSLNegotiation.postgres\n            )\n        else:\n            if sslnegotiation is None:\n                sslnegotiation = os.environ.get(&amp;quot;PGSSLNEGOTIATION&amp;quot;)\n    \n            if sslnegotiation is not None:\n                try:\n                    sslneg = SSLNegotiation(sslnegotiation)\n                except ValueError:\n                    modes = &amp;#x27;, &amp;#x27;.join(\n                        m.name.replace(&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;)\n                        for m in SSLNegotiation\n                    )\n&amp;gt;                   raise exceptions.ClientConfigurationError(\n                        f&amp;#x27;`sslnegotiation` parameter must be one of: {modes}&amp;#x27;\n                    ) from None\nE                   asyncpg.exceptions._base.ClientConfigurationError: `sslnegotiation` parameter must be one of: postgres, direct\n\n.venv\\lib\\site-packages\\asyncpg\\connect_utils.py:531: ClientConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @pytest.fixture(scope=&amp;quot;session&amp;quot;)\n    def client(app: Any) -&amp;gt; Generator[Any, None, None]:\n        &amp;quot;&amp;quot;&amp;quot;Create test client.&amp;quot;&amp;quot;&amp;quot;\n        from fastapi.testclient import TestClient\n&amp;gt;       with TestClient(app) as test_client:\n\nbackend\\tests\\conftest.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:680: in __enter__\n    portal.call(self.wait_startup)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:715: in wait_startup\n    await receive()\n.venv\\lib\\site-packages\\starlette\\testclient.py:706: in receive\n    self.task.result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:451: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\starlette\\testclient.py:696: in lifespan\n    await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:152: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:77: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:48: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:723: in app\n    await self.lifespan(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:692: in lifespan\n    async with self.lifespan_context(app) as maybe_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n.venv\\lib\\site-packages\\fastapi\\routing.py:133: in merged_lifespan\n    async with original_context(app) as maybe_original_state:\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:199: in __aenter__\n    return await anext(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\napp = &amp;lt;fastapi.applications.FastAPI object at 0x0000023171C03CA0&amp;gt;\n\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        &amp;quot;&amp;quot;&amp;quot;Lifespan context manager for FastAPI application.&amp;quot;&amp;quot;&amp;quot;\n        try:\n            # Initialize system bootstrap first\n            system = SystemBootstrap()\n            await system.initialize()\n    \n            # Initialize database\n            logger.info(&amp;quot;Initializing database...&amp;quot;)\n            await db_pool.initialize()\n    \n            # Initialize face recognition system only if enabled\n            if settings.ENABLE_FACE_RECOGNITION:\n                logger.info(&amp;quot;Initializing face recognition system...&amp;quot;)\n                await face_recognition_system.initialize()\n            else:\n                logger.info(&amp;quot;Face recognition is disabled&amp;quot;)\n    \n            logger.info(&amp;quot;Application initialized successfully&amp;quot;)\n            yield\n        except Exception as e:\n            logger.error(f&amp;quot;Failed to initialize application: {str(e)}&amp;quot;)\n            raise\n        finally:\n            # Cleanup in reverse order\n            logger.info(&amp;quot;Starting application cleanup...&amp;quot;)\n            if settings.ENABLE_FACE_RECOGNITION:\n&amp;gt;               await face_recognition_system.cleanup()\nE               TypeError: object MagicMock can&amp;#x27;t be used in &amp;#x27;await&amp;#x27; expression\n\nbackend\\src\\main.py:70: TypeError\n&#34;}], &#34;backend/tests/test_core/test_models.py::test_create_access_log&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_models.py::test_create_access_log::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_models.py::test_create_access_log::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py, line 52\n  def test_create_access_log(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py:52\n&#34;}], &#34;backend/tests/test_core/test_models.py::test_cascade_delete_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_models.py::test_cascade_delete_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_models.py::test_cascade_delete_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py, line 81\n  def test_cascade_delete_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py:81\n&#34;}], &#34;backend/tests/test_core/test_models.py::test_create_face_encoding&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_models.py::test_create_face_encoding::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_models.py::test_create_face_encoding::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py, line 26\n  def test_create_face_encoding(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py:26\n&#34;}], &#34;backend/tests/test_core/test_models.py::test_create_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_models.py::test_create_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_models.py::test_create_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py, line 6\n  def test_create_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py:6\n&#34;}], &#34;backend/tests/test_core/test_models.py::test_unique_constraints&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_core/test_models.py::test_unique_constraints::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_core/test_models.py::test_unique_constraints::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py, line 116\n  def test_unique_constraints(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_core\\test_models.py:116\n&#34;}], &#34;backend/tests/test_migrations.py::test_migration_history_table&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_migrations.py::test_migration_history_table::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_migrations.py::test_migration_history_table::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_migrations.py, line 44\n  def test_migration_history_table(engine):\nE       fixture &amp;#x27;engine&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_migrations.py:44\n&#34;}], &#34;backend/tests/test_migrations.py::test_users_table_structure&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_migrations.py::test_users_table_structure::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_migrations.py::test_users_table_structure::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_migrations.py, line 4\n  def test_users_table_structure(engine):\nE       fixture &amp;#x27;engine&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_migrations.py:4\n&#34;}], &#34;backend/tests/test_api.py::test_update_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_update_user::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_update_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 79\n  def test_update_user(client, token, test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 26\n  @pytest.fixture\n  def token(test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 13\n  @pytest.fixture\n  def test_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:13\n&#34;}], &#34;backend/tests/test_api.py::test_unauthorized_access&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_unauthorized_access&#34;, &#34;duration&#34;: &#34;7 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_unauthorized_access&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;7 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;starlette.testclient.TestClient object at 0x0000023172D77820&amp;gt;\n\n    def test_unauthorized_access(client):\n        &amp;quot;&amp;quot;&amp;quot;Test unauthorized access to protected endpoints.&amp;quot;&amp;quot;&amp;quot;\n        response = client.get(&amp;quot;/api/users/me&amp;quot;)\n&amp;gt;       assert response.status_code == 401\nE       assert == failed. [pytest-clarity diff shown]\nE         \nE         LHS vs RHS shown below\nE         \nE         404\nE         401\nE         \n\nbackend\\tests\\test_api.py:95: AssertionError\n\n----------------------------- Captured stderr call -----------------------------\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;httpx&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;HTTP Request: GET http://testserver/api/users/me \\&amp;quot;HTTP/1.1 404 Not Found\\&amp;quot;&amp;quot;}\n\n------------------------------ Captured log call -------------------------------\nINFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/users/me &amp;quot;HTTP/1.1 404 Not Found&amp;quot;\n\n&#34;}], &#34;backend/tests/test_api.py::test_health_check&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_health_check&#34;, &#34;duration&#34;: &#34;5 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_health_check&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;5 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;starlette.testclient.TestClient object at 0x0000023172A03280&amp;gt;\n\n    def test_health_check(client):\n        &amp;quot;&amp;quot;&amp;quot;Test health check endpoint.&amp;quot;&amp;quot;&amp;quot;\n&amp;gt;       response = client.get(&amp;quot;/health&amp;quot;)\n\nbackend\\tests\\test_api.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\lib\\site-packages\\starlette\\testclient.py:465: in get\n    return super().get(\n.venv\\lib\\site-packages\\httpx\\_client.py:1041: in get\n    return self.request(\n.venv\\lib\\site-packages\\starlette\\testclient.py:437: in request\n    return super().request(\n.venv\\lib\\site-packages\\httpx\\_client.py:814: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n.venv\\lib\\site-packages\\httpx\\_client.py:901: in send\n    response = self._send_handling_auth(\n.venv\\lib\\site-packages\\httpx\\_client.py:929: in _send_handling_auth\n    response = self._send_handling_redirects(\n.venv\\lib\\site-packages\\httpx\\_client.py:966: in _send_handling_redirects\n    response = self._send_single_request(request)\n.venv\\lib\\site-packages\\httpx\\_client.py:1002: in _send_single_request\n    response = transport.handle_request(request)\n.venv\\lib\\site-packages\\starlette\\testclient.py:340: in handle_request\n    raise exc\n.venv\\lib\\site-packages\\starlette\\testclient.py:337: in handle_request\n    portal.call(self.app, scope, receive, send)\n.venv\\lib\\site-packages\\anyio\\from_thread.py:290: in call\n    return cast(T_Retval, self.start_task_soon(func, *args).result())\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:458: in result\n    return self.__get_result()\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\concurrent\\futures\\_base.py:403: in __get_result\n    raise self._exception\n.venv\\lib\\site-packages\\anyio\\from_thread.py:221: in _call_func\n    retval = await retval_or_awaitable\n.venv\\lib\\site-packages\\fastapi\\applications.py:1054: in __call__\n    await super().__call__(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\applications.py:112: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:187: in __call__\n    raise exc\n.venv\\lib\\site-packages\\starlette\\middleware\\errors.py:165: in __call__\n    await self.app(scope, receive, _send)\n.venv\\lib\\site-packages\\starlette\\middleware\\cors.py:85: in __call__\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\middleware\\exceptions.py:62: in __call__\n    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\_exception_handler.py:53: in wrapped_app\n    raise exc\n.venv\\lib\\site-packages\\starlette\\_exception_handler.py:42: in wrapped_app\n    await app(scope, receive, sender)\n.venv\\lib\\site-packages\\starlette\\routing.py:714: in __call__\n    await self.middleware_stack(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:734: in app\n    await route.handle(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:288: in handle\n    await self.app(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\routing.py:76: in app\n    await wrap_app_handling_exceptions(app, request)(scope, receive, send)\n.venv\\lib\\site-packages\\starlette\\_exception_handler.py:53: in wrapped_app\n    raise exc\n.venv\\lib\\site-packages\\starlette\\_exception_handler.py:42: in wrapped_app\n    await app(scope, receive, sender)\n.venv\\lib\\site-packages\\starlette\\routing.py:73: in app\n    response = await f(request)\n.venv\\lib\\site-packages\\fastapi\\routing.py:327: in app\n    content = await serialize_response(\n.venv\\lib\\site-packages\\fastapi\\routing.py:201: in serialize_response\n    return jsonable_encoder(response_content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nobj = {&amp;#x27;status&amp;#x27;: &amp;#x27;healthy&amp;#x27;}, include = None, exclude = None, by_alias = True, exclude_unset = False\nexclude_defaults = False, exclude_none = False, custom_encoder = {}, sqlalchemy_safe = True\n\n    def jsonable_encoder(\n        obj: Annotated[\n            Any,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                The input object to convert to JSON.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ],\n        include: Annotated[\n            Optional[IncEx],\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `include` parameter, passed to Pydantic models to set the\n                fields to include.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = None,\n        exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `exclude` parameter, passed to Pydantic models to set the\n                fields to exclude.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = None,\n        by_alias: Annotated[\n            bool,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `by_alias` parameter, passed to Pydantic models to define if\n                the output should use the alias names (when provided) or the Python\n                attribute names. In an API, if you set an alias, it&amp;#x27;s probably because you\n                want to use it in the result, so you probably want to leave this set to\n                `True`.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = True,\n        exclude_unset: Annotated[\n            bool,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `exclude_unset` parameter, passed to Pydantic models to define\n                if it should exclude from the output the fields that were not explicitly\n                set (and that only had their default values).\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = False,\n        exclude_defaults: Annotated[\n            bool,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `exclude_defaults` parameter, passed to Pydantic models to define\n                if it should exclude from the output the fields that had the same default\n                value, even when they were explicitly set.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = False,\n        exclude_none: Annotated[\n            bool,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `exclude_none` parameter, passed to Pydantic models to define\n                if it should exclude from the output any fields that have a `None` value.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = False,\n        custom_encoder: Annotated[\n            Optional[Dict[Any, Callable[[Any], Any]]],\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Pydantic&amp;#x27;s `custom_encoder` parameter, passed to Pydantic models to define\n                a custom encoder.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = None,\n        sqlalchemy_safe: Annotated[\n            bool,\n            Doc(\n                &amp;quot;&amp;quot;&amp;quot;\n                Exclude from the output any fields that start with the name `_sa`.\n    \n                This is mainly a hack for compatibility with SQLAlchemy objects, they\n                store internal SQLAlchemy-specific state in attributes named with `_sa`,\n                and those objects can&amp;#x27;t (and shouldn&amp;#x27;t be) serialized to JSON.\n                &amp;quot;&amp;quot;&amp;quot;\n            ),\n        ] = True,\n    ) -&amp;gt; Any:\n        &amp;quot;&amp;quot;&amp;quot;\n        Convert any object to something that can be encoded in JSON.\n    \n        This is used internally by FastAPI to make sure anything you return can be\n        encoded as JSON before it is sent to the client.\n    \n        You can also use it yourself, for example to convert objects before saving them\n        in a database that supports only JSON.\n    \n        Read more about it in the\n        [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n        &amp;quot;&amp;quot;&amp;quot;\n        custom_encoder = custom_encoder or {}\n        if custom_encoder:\n            if type(obj) in custom_encoder:\n                return custom_encoder[type(obj)](obj)\n            else:\n                for encoder_type, encoder_instance in custom_encoder.items():\n                    if isinstance(obj, encoder_type):\n                        return encoder_instance(obj)\n        if include is not None and not isinstance(include, (set, dict)):\n            include = set(include)\n        if exclude is not None and not isinstance(exclude, (set, dict)):\n            exclude = set(exclude)\n        if isinstance(obj, BaseModel):\n            # TODO: remove when deprecating Pydantic v1\n            encoders: Dict[Any, Any] = {}\n            if not PYDANTIC_V2:\n                encoders = getattr(obj.__config__, &amp;quot;json_encoders&amp;quot;, {})  # type: ignore[attr-defined]\n                if custom_encoder:\n                    encoders.update(custom_encoder)\n            obj_dict = _model_dump(\n                obj,\n                mode=&amp;quot;json&amp;quot;,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_none=exclude_none,\n                exclude_defaults=exclude_defaults,\n            )\n            if &amp;quot;__root__&amp;quot; in obj_dict:\n                obj_dict = obj_dict[&amp;quot;__root__&amp;quot;]\n            return jsonable_encoder(\n                obj_dict,\n                exclude_none=exclude_none,\n                exclude_defaults=exclude_defaults,\n                # TODO: remove when deprecating Pydantic v1\n                custom_encoder=encoders,\n                sqlalchemy_safe=sqlalchemy_safe,\n            )\n        if dataclasses.is_dataclass(obj):\n            obj_dict = dataclasses.asdict(obj)\n            return jsonable_encoder(\n                obj_dict,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                custom_encoder=custom_encoder,\n                sqlalchemy_safe=sqlalchemy_safe,\n            )\n        if isinstance(obj, Enum):\n            return obj.value\n&amp;gt;       if isinstance(obj, PurePath):\nE       TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union\n\n.venv\\lib\\site-packages\\fastapi\\encoders.py:258: TypeError\n&#34;}], &#34;backend/tests/test_api.py::test_login_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_login_user::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_login_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 54\n  def test_login_user(client, test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 13\n  @pytest.fixture\n  def test_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:13\n&#34;}], &#34;backend/tests/test_api.py::test_face_recognition_endpoint&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_face_recognition_endpoint::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_face_recognition_endpoint::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 105\n  def test_face_recognition_endpoint(client, token, test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 26\n  @pytest.fixture\n  def token(test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 13\n  @pytest.fixture\n  def test_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:13\n&#34;}], &#34;backend/tests/test_api.py::test_register_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_register_user::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_register_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 37\n  def test_register_user(client, db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:37\n&#34;}], &#34;backend/tests/test_api.py::test_access_log_creation&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_access_log_creation::setup&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_access_log_creation::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 118\n  def test_access_log_creation(client, token, test_user, db_session):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 26\n  @pytest.fixture\n  def token(test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 13\n  @pytest.fixture\n  def test_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:13\n&#34;}], &#34;backend/tests/test_api.py::test_invalid_token&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_invalid_token&#34;, &#34;duration&#34;: &#34;6 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_invalid_token&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;6 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;starlette.testclient.TestClient object at 0x0000023172C93610&amp;gt;\n\n    def test_invalid_token(client):\n        &amp;quot;&amp;quot;&amp;quot;Test access with invalid token.&amp;quot;&amp;quot;&amp;quot;\n        response = client.get(\n            &amp;quot;/api/users/me&amp;quot;,\n            headers={&amp;quot;Authorization&amp;quot;: &amp;quot;Bearer invalid_token&amp;quot;}\n        )\n&amp;gt;       assert response.status_code == 401\nE       assert == failed. [pytest-clarity diff shown]\nE         \nE         LHS vs RHS shown below\nE         \nE         404\nE         401\nE         \n\nbackend\\tests\\test_api.py:103: AssertionError\n\n----------------------------- Captured stderr call -----------------------------\n{&amp;quot;timestamp&amp;quot;: null, &amp;quot;level&amp;quot;: null, &amp;quot;name&amp;quot;: &amp;quot;httpx&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;HTTP Request: GET http://testserver/api/users/me \\&amp;quot;HTTP/1.1 404 Not Found\\&amp;quot;&amp;quot;}\n\n------------------------------ Captured log call -------------------------------\nINFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/users/me &amp;quot;HTTP/1.1 404 Not Found&amp;quot;\n\n&#34;}], &#34;backend/tests/test_api.py::test_get_current_user&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;backend/tests/test_api.py::test_get_current_user::setup&#34;, &#34;duration&#34;: &#34;0 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;backend/tests/test_api.py::test_get_current_user::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;0 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;file C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 68\n  def test_get_current_user(client, token, test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 26\n  @pytest.fixture\n  def token(test_user):\nfile C:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py, line 13\n  @pytest.fixture\n  def test_user(db_session):\nE       fixture &amp;#x27;db_session&amp;#x27; not found\n&amp;gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, app, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, client, cov, doctest_namespace, event_loop, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mock_face_detector, mock_face_matcher, mock_face_recognizer, mock_gpu, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, setup_test_env, test_image, test_image_file, test_settings, test_user, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, token, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id\n&amp;gt;       use &amp;#x27;pytest --fixtures [testpath]&amp;#x27; for help on them.\n\nC:\\Users\\maces\\Documents\\CernoID-Complete-1\\backend\\tests\\test_api.py:13\n&#34;}]}, &#34;renderCollapsed&#34;: [&#34;passed&#34;], &#34;initialSort&#34;: &#34;result&#34;, &#34;title&#34;: &#34;test-report.html&#34;}"></div>
    <script>
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const { getCollapsedCategory, setCollapsedIds } = require('./storage.js')

class DataManager {
    setManager(data) {
        const collapsedCategories = [...getCollapsedCategory(data.renderCollapsed)]
        const collapsedIds = []
        const tests = Object.values(data.tests).flat().map((test, index) => {
            const collapsed = collapsedCategories.includes(test.result.toLowerCase())
            const id = `test_${index}`
            if (collapsed) {
                collapsedIds.push(id)
            }
            return {
                ...test,
                id,
                collapsed,
            }
        })
        const dataBlob = { ...data, tests }
        this.data = { ...dataBlob }
        this.renderData = { ...dataBlob }
        setCollapsedIds(collapsedIds)
    }

    get allData() {
        return { ...this.data }
    }

    resetRender() {
        this.renderData = { ...this.data }
    }

    setRender(data) {
        this.renderData.tests = [...data]
    }

    toggleCollapsedItem(id) {
        this.renderData.tests = this.renderData.tests.map((test) =>
            test.id === id ? { ...test, collapsed: !test.collapsed } : test,
        )
    }

    set allCollapsed(collapsed) {
        this.renderData = { ...this.renderData, tests: [...this.renderData.tests.map((test) => (
            { ...test, collapsed }
        ))] }
    }

    get testSubset() {
        return [...this.renderData.tests]
    }

    get environment() {
        return this.renderData.environment
    }

    get initialSort() {
        return this.data.initialSort
    }
}

module.exports = {
    manager: new DataManager(),
}

},{"./storage.js":8}],2:[function(require,module,exports){
const mediaViewer = require('./mediaviewer.js')
const templateEnvRow = document.getElementById('template_environment_row')
const templateResult = document.getElementById('template_results-table__tbody')

function htmlToElements(html) {
    const temp = document.createElement('template')
    temp.innerHTML = html
    return temp.content.childNodes
}

const find = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return elem.querySelector(selector)
}

const findAll = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return [...elem.querySelectorAll(selector)]
}

const dom = {
    getStaticRow: (key, value) => {
        const envRow = templateEnvRow.content.cloneNode(true)
        const isObj = typeof value === 'object' && value !== null
        const values = isObj ? Object.keys(value).map((k) => `${k}: ${value[k]}`) : null

        const valuesElement = htmlToElements(
            values ? `<ul>${values.map((val) => `<li>${val}</li>`).join('')}<ul>` : `<div>${value}</div>`)[0]
        const td = findAll('td', envRow)
        td[0].textContent = key
        td[1].appendChild(valuesElement)

        return envRow
    },
    getResultTBody: ({ testId, id, log, extras, resultsTableRow, tableHtml, result, collapsed }) => {
        const resultBody = templateResult.content.cloneNode(true)
        resultBody.querySelector('tbody').classList.add(result.toLowerCase())
        resultBody.querySelector('tbody').id = testId
        resultBody.querySelector('.collapsible').dataset.id = id

        resultsTableRow.forEach((html) => {
            const t = document.createElement('template')
            t.innerHTML = html
            resultBody.querySelector('.collapsible').appendChild(t.content)
        })

        if (log) {
            // Wrap lines starting with "E" with span.error to color those lines red
            const wrappedLog = log.replace(/^E.*$/gm, (match) => `<span class="error">${match}</span>`)
            resultBody.querySelector('.log').innerHTML = wrappedLog
        } else {
            resultBody.querySelector('.log').remove()
        }

        if (collapsed) {
            resultBody.querySelector('.collapsible > td')?.classList.add('collapsed')
            resultBody.querySelector('.extras-row').classList.add('hidden')
        } else {
            resultBody.querySelector('.collapsible > td')?.classList.remove('collapsed')
        }

        const media = []
        extras?.forEach(({ name, format_type, content }) => {
            if (['image', 'video'].includes(format_type)) {
                media.push({ path: content, name, format_type })
            }

            if (format_type === 'html') {
                resultBody.querySelector('.extraHTML').insertAdjacentHTML('beforeend', `<div>${content}</div>`)
            }
        })
        mediaViewer.setup(resultBody, media)

        // Add custom html from the pytest_html_results_table_html hook
        tableHtml?.forEach((item) => {
            resultBody.querySelector('td[class="extra"]').insertAdjacentHTML('beforeend', item)
        })

        return resultBody
    },
}

module.exports = {
    dom,
    htmlToElements,
    find,
    findAll,
}

},{"./mediaviewer.js":6}],3:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const storageModule = require('./storage.js')

const getFilteredSubSet = (filter) =>
    manager.allData.tests.filter(({ result }) => filter.includes(result.toLowerCase()))

const doInitFilter = () => {
    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)
}

const doFilter = (type, show) => {
    if (show) {
        storageModule.showCategory(type)
    } else {
        storageModule.hideCategory(type)
    }

    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)

    const sortColumn = storageModule.getSort()
    doSort(sortColumn, true)
}

module.exports = {
    doFilter,
    doInitFilter,
}

},{"./datamanager.js":1,"./sort.js":7,"./storage.js":8}],4:[function(require,module,exports){
const { redraw, bindEvents, renderStatic } = require('./main.js')
const { doInitFilter } = require('./filter.js')
const { doInitSort } = require('./sort.js')
const { manager } = require('./datamanager.js')
const data = JSON.parse(document.getElementById('data-container').dataset.jsonblob)

function init() {
    manager.setManager(data)
    doInitFilter()
    doInitSort()
    renderStatic()
    redraw()
    bindEvents()
}

init()

},{"./datamanager.js":1,"./filter.js":3,"./main.js":5,"./sort.js":7}],5:[function(require,module,exports){
const { dom, find, findAll } = require('./dom.js')
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const { doFilter } = require('./filter.js')
const {
    getVisible,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    getSortDirection,
    possibleFilters,
} = require('./storage.js')

const removeChildren = (node) => {
    while (node.firstChild) {
        node.removeChild(node.firstChild)
    }
}

const renderStatic = () => {
    const renderEnvironmentTable = () => {
        const environment = manager.environment
        const rows = Object.keys(environment).map((key) => dom.getStaticRow(key, environment[key]))
        const table = document.getElementById('environment')
        removeChildren(table)
        rows.forEach((row) => table.appendChild(row))
    }
    renderEnvironmentTable()
}

const addItemToggleListener = (elem) => {
    elem.addEventListener('click', ({ target }) => {
        const id = target.parentElement.dataset.id
        manager.toggleCollapsedItem(id)

        const collapsedIds = getCollapsedIds()
        if (collapsedIds.includes(id)) {
            const updated = collapsedIds.filter((item) => item !== id)
            setCollapsedIds(updated)
        } else {
            collapsedIds.push(id)
            setCollapsedIds(collapsedIds)
        }
        redraw()
    })
}

const renderContent = (tests) => {
    const sortAttr = getSort(manager.initialSort)
    const sortAsc = JSON.parse(getSortDirection())
    const rows = tests.map(dom.getResultTBody)
    const table = document.getElementById('results-table')
    const tableHeader = document.getElementById('results-table-head')

    const newTable = document.createElement('table')
    newTable.id = 'results-table'

    // remove all sorting classes and set the relevant
    findAll('.sortable', tableHeader).forEach((elem) => elem.classList.remove('asc', 'desc'))
    tableHeader.querySelector(`.sortable[data-column-type="${sortAttr}"]`)?.classList.add(sortAsc ? 'desc' : 'asc')
    newTable.appendChild(tableHeader)

    if (!rows.length) {
        const emptyTable = document.getElementById('template_results-table__body--empty').content.cloneNode(true)
        newTable.appendChild(emptyTable)
    } else {
        rows.forEach((row) => {
            if (!!row) {
                findAll('.collapsible td:not(.col-links', row).forEach(addItemToggleListener)
                find('.logexpander', row).addEventListener('click',
                    (evt) => evt.target.parentNode.classList.toggle('expanded'),
                )
                newTable.appendChild(row)
            }
        })
    }

    table.replaceWith(newTable)
}

const renderDerived = () => {
    const currentFilter = getVisible()
    possibleFilters.forEach((result) => {
        const input = document.querySelector(`input[data-test-result="${result}"]`)
        input.checked = currentFilter.includes(result)
    })
}

const bindEvents = () => {
    const filterColumn = (evt) => {
        const { target: element } = evt
        const { testResult } = element.dataset

        doFilter(testResult, element.checked)
        const collapsedIds = getCollapsedIds()
        const updated = manager.renderData.tests.map((test) => {
            return {
                ...test,
                collapsed: collapsedIds.includes(test.id),
            }
        })
        manager.setRender(updated)
        redraw()
    }

    const header = document.getElementById('environment-header')
    header.addEventListener('click', () => {
        const table = document.getElementById('environment')
        table.classList.toggle('hidden')
        header.classList.toggle('collapsed')
    })

    findAll('input[name="filter_checkbox"]').forEach((elem) => {
        elem.addEventListener('click', filterColumn)
    })

    findAll('.sortable').forEach((elem) => {
        elem.addEventListener('click', (evt) => {
            const { target: element } = evt
            const { columnType } = element.dataset
            doSort(columnType)
            redraw()
        })
    })

    document.getElementById('show_all_details').addEventListener('click', () => {
        manager.allCollapsed = false
        setCollapsedIds([])
        redraw()
    })
    document.getElementById('hide_all_details').addEventListener('click', () => {
        manager.allCollapsed = true
        const allIds = manager.renderData.tests.map((test) => test.id)
        setCollapsedIds(allIds)
        redraw()
    })
}

const redraw = () => {
    const { testSubset } = manager

    renderContent(testSubset)
    renderDerived()
}

module.exports = {
    redraw,
    bindEvents,
    renderStatic,
}

},{"./datamanager.js":1,"./dom.js":2,"./filter.js":3,"./sort.js":7,"./storage.js":8}],6:[function(require,module,exports){
class MediaViewer {
    constructor(assets) {
        this.assets = assets
        this.index = 0
    }

    nextActive() {
        this.index = this.index === this.assets.length - 1 ? 0 : this.index + 1
        return [this.activeFile, this.index]
    }

    prevActive() {
        this.index = this.index === 0 ? this.assets.length - 1 : this.index -1
        return [this.activeFile, this.index]
    }

    get currentIndex() {
        return this.index
    }

    get activeFile() {
        return this.assets[this.index]
    }
}


const setup = (resultBody, assets) => {
    if (!assets.length) {
        resultBody.querySelector('.media').classList.add('hidden')
        return
    }

    const mediaViewer = new MediaViewer(assets)
    const container = resultBody.querySelector('.media-container')
    const leftArrow = resultBody.querySelector('.media-container__nav--left')
    const rightArrow = resultBody.querySelector('.media-container__nav--right')
    const mediaName = resultBody.querySelector('.media__name')
    const counter = resultBody.querySelector('.media__counter')
    const imageEl = resultBody.querySelector('img')
    const sourceEl = resultBody.querySelector('source')
    const videoEl = resultBody.querySelector('video')

    const setImg = (media, index) => {
        if (media?.format_type === 'image') {
            imageEl.src = media.path

            imageEl.classList.remove('hidden')
            videoEl.classList.add('hidden')
        } else if (media?.format_type === 'video') {
            sourceEl.src = media.path

            videoEl.classList.remove('hidden')
            imageEl.classList.add('hidden')
        }

        mediaName.innerText = media?.name
        counter.innerText = `${index + 1} / ${assets.length}`
    }
    setImg(mediaViewer.activeFile, mediaViewer.currentIndex)

    const moveLeft = () => {
        const [media, index] = mediaViewer.prevActive()
        setImg(media, index)
    }
    const doRight = () => {
        const [media, index] = mediaViewer.nextActive()
        setImg(media, index)
    }
    const openImg = () => {
        window.open(mediaViewer.activeFile.path, '_blank')
    }
    if (assets.length === 1) {
        container.classList.add('media-container--fullscreen')
    } else {
        leftArrow.addEventListener('click', moveLeft)
        rightArrow.addEventListener('click', doRight)
    }
    imageEl.addEventListener('click', openImg)
}

module.exports = {
    setup,
}

},{}],7:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const storageModule = require('./storage.js')

const genericSort = (list, key, ascending, customOrder) => {
    let sorted
    if (customOrder) {
        sorted = list.sort((a, b) => {
            const aValue = a.result.toLowerCase()
            const bValue = b.result.toLowerCase()

            const aIndex = customOrder.findIndex((item) => item.toLowerCase() === aValue)
            const bIndex = customOrder.findIndex((item) => item.toLowerCase() === bValue)

            // Compare the indices to determine the sort order
            return aIndex - bIndex
        })
    } else {
        sorted = list.sort((a, b) => a[key] === b[key] ? 0 : a[key] > b[key] ? 1 : -1)
    }

    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const durationSort = (list, ascending) => {
    const parseDuration = (duration) => {
        if (duration.includes(':')) {
            // If it's in the format "HH:mm:ss"
            const [hours, minutes, seconds] = duration.split(':').map(Number)
            return (hours * 3600 + minutes * 60 + seconds) * 1000
        } else {
            // If it's in the format "nnn ms"
            return parseInt(duration)
        }
    }
    const sorted = list.sort((a, b) => parseDuration(a['duration']) - parseDuration(b['duration']))
    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const doInitSort = () => {
    const type = storageModule.getSort(manager.initialSort)
    const ascending = storageModule.getSortDirection()
    const list = manager.testSubset
    const initialOrder = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed', 'Skipped', 'Passed']

    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    if (type?.toLowerCase() === 'original') {
        manager.setRender(list)
    } else {
        let sortedList
        switch (type) {
        case 'duration':
            sortedList = durationSort(list, ascending)
            break
        case 'result':
            sortedList = genericSort(list, type, ascending, initialOrder)
            break
        default:
            sortedList = genericSort(list, type, ascending)
            break
        }
        manager.setRender(sortedList)
    }
}

const doSort = (type, skipDirection) => {
    const newSortType = storageModule.getSort(manager.initialSort) !== type
    const currentAsc = storageModule.getSortDirection()
    let ascending
    if (skipDirection) {
        ascending = currentAsc
    } else {
        ascending = newSortType ? false : !currentAsc
    }
    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    const list = manager.testSubset
    const sortedList = type === 'duration' ? durationSort(list, ascending) : genericSort(list, type, ascending)
    manager.setRender(sortedList)
}

module.exports = {
    doInitSort,
    doSort,
}

},{"./datamanager.js":1,"./storage.js":8}],8:[function(require,module,exports){
const possibleFilters = [
    'passed',
    'skipped',
    'failed',
    'error',
    'xfailed',
    'xpassed',
    'rerun',
]

const getVisible = () => {
    const url = new URL(window.location.href)
    const settings = new URLSearchParams(url.search).get('visible')
    const lower = (item) => {
        const lowerItem = item.toLowerCase()
        if (possibleFilters.includes(lowerItem)) {
            return lowerItem
        }
        return null
    }
    return settings === null ?
        possibleFilters :
        [...new Set(settings?.split(',').map(lower).filter((item) => item))]
}

const hideCategory = (categoryToHide) => {
    const url = new URL(window.location.href)
    const visibleParams = new URLSearchParams(url.search).get('visible')
    const currentVisible = visibleParams ? visibleParams.split(',') : [...possibleFilters]
    const settings = [...new Set(currentVisible)].filter((f) => f !== categoryToHide).join(',')

    url.searchParams.set('visible', settings)
    window.history.pushState({}, null, unescape(url.href))
}

const showCategory = (categoryToShow) => {
    if (typeof window === 'undefined') {
        return
    }
    const url = new URL(window.location.href)
    const currentVisible = new URLSearchParams(url.search).get('visible')?.split(',').filter(Boolean) ||
        [...possibleFilters]
    const settings = [...new Set([categoryToShow, ...currentVisible])]
    const noFilter = possibleFilters.length === settings.length || !settings.length

    noFilter ? url.searchParams.delete('visible') : url.searchParams.set('visible', settings.join(','))
    window.history.pushState({}, null, unescape(url.href))
}

const getSort = (initialSort) => {
    const url = new URL(window.location.href)
    let sort = new URLSearchParams(url.search).get('sort')
    if (!sort) {
        sort = initialSort || 'result'
    }
    return sort
}

const setSort = (type) => {
    const url = new URL(window.location.href)
    url.searchParams.set('sort', type)
    window.history.pushState({}, null, unescape(url.href))
}

const getCollapsedCategory = (renderCollapsed) => {
    let categories
    if (typeof window !== 'undefined') {
        const url = new URL(window.location.href)
        const collapsedItems = new URLSearchParams(url.search).get('collapsed')
        switch (true) {
        case !renderCollapsed && collapsedItems === null:
            categories = ['passed']
            break
        case collapsedItems?.length === 0 || /^["']{2}$/.test(collapsedItems):
            categories = []
            break
        case /^all$/.test(collapsedItems) || collapsedItems === null && /^all$/.test(renderCollapsed):
            categories = [...possibleFilters]
            break
        default:
            categories = collapsedItems?.split(',').map((item) => item.toLowerCase()) || renderCollapsed
            break
        }
    } else {
        categories = []
    }
    return categories
}

const getSortDirection = () => JSON.parse(sessionStorage.getItem('sortAsc')) || false
const setSortDirection = (ascending) => sessionStorage.setItem('sortAsc', ascending)

const getCollapsedIds = () => JSON.parse(sessionStorage.getItem('collapsedIds')) || []
const setCollapsedIds = (list) => sessionStorage.setItem('collapsedIds', JSON.stringify(list))

module.exports = {
    getVisible,
    hideCategory,
    showCategory,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    setSort,
    getSortDirection,
    setSortDirection,
    getCollapsedCategory,
    possibleFilters,
}

},{}]},{},[4]);
    </script>
  </footer>
</html>